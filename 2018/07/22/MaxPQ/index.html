<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>优先队列 | 开开｜初开</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">优先队列</h1><a id="logo" href="/.">开开｜初开</a><p class="description">分享技术,记录生活</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">优先队列</h1><div class="post-meta">Jul 22, 2018</div><div class="post-content"><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>　　许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序，很多情况下我们会收集一些元素，处理当前最大的元素，然后再收集更多元素，然后再处理当前键值最大的值。要处理这种情况，就引出了优先队列的概念，这种类型支持两种操作，删除最大的元素和插入元素，这是一种抽象数据类型，为此定义出如下结构<br></p>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123;</span><br><span class="line">    MaxPQ()&#123;&#125;</span><br><span class="line">    MaxPQ(int M)&#123;&#125;</span><br><span class="line">    MaxPQ(Key[] a)&#123;&#125;</span><br><span class="line">    void insert(Key v)&#123;&#125;</span><br><span class="line">    Key delMax()&#123;return null;&#125;;</span><br><span class="line">    boolean isEmpty()&#123;return false;&#125;;</span><br><span class="line">    int size()&#123;return 0;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　既然这是一种抽象的数据类型，那么我们要怎么实现呢?最简单的做法就是用无序的数组实现，那么insert()的时间复杂度就为1，而取出来的时间复杂度就为n(无序数组取最大值)。这种结构不是很理想。那么应该用什么数据类型呢？我们下面先说下几个概念</p>

<h5 id="堆有序：当一颗二叉树的每一个节点都大于或等于它的两个子节点时，称为堆有序"><a href="#堆有序：当一颗二叉树的每一个节点都大于或等于它的两个子节点时，称为堆有序" class="headerlink" title="堆有序：当一颗二叉树的每一个节点都大于或等于它的两个子节点时，称为堆有序"></a>堆有序：当一颗二叉树的每一个节点都大于或等于它的两个子节点时，称为堆有序</h5><p>　　从以上的定义可以得到 -&gt;  根节点是堆有序的二叉树的最大节点。那么我们用这种数据结构来实现优先队列，是不是更好呢。如果我们用指针来表示堆有序的二叉树，那么每一个元素都需要三个指针来找到它的上下节点(一个父节点和两个子节点)。如果我们用完全二叉树，表达就会特别方便。</p><br><br>##### 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存(不使用数组的第一个位置)<br><br><p>　　既然我们选择这种模式，那么我们有序化这个堆的时候，会遇到两种情况，当某个节点的优先级上升(或者在堆底加入一个新的元素)时，我们需要由下至上恢复堆的顺序，当某个节点的优先级下降的时候，我们需要由上之下恢复堆的顺序。那我们再研究下这个上浮算法和下沉算法。</p>


<h4 id="上浮算法"><a href="#上浮算法" class="headerlink" title="上浮算法"></a>上浮算法</h4><p>　　如果堆的有序状态因为某个节点变得比它的父节点更大而被打破，那么我们就需要通过交换它和它父节点来修复堆，交换后，这个节点比它的两个子节点都大，但是这个节点仍可以比它现在的父节点大，那么我们需要再通过此方法上浮，上浮的最大点是第一层，那么当该节点不在第一层且大于父节点，那么就需要继续上移。由分析可能以下代码</p><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void swim(int k)&#123;</span><br><span class="line">     while (k&gt;1 &amp;&amp; less(k/2,k))&#123;</span><br><span class="line">         exch(k/2,k);</span><br><span class="line">         k = k /2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><br>#### 下沉算法<br><br><p>　　当有序堆因为某个节点变得比它的两个节点或者其中之一更小了而被打破了有序。那么我们可以通过它和它的子节点中的较大值交换来恢复堆。交换可能在节点处继续打破堆的有序性。因此我们需要不断的用这个方法来修复。看如下代码</p>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void sink(int k)&#123;</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            int j = 2*k;</span><br><span class="line">            if(j&lt;N &amp;&amp; less(j,j+1)) j ++;</span><br><span class="line">            if(!less(k,j)) break;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　有序堆的整理实现了，那怎么实现优先队列的插入和删除最大值呢，我可以想象这个堆就像是黑社会的一个社团一样，一个新人加入的时候，就会努力上浮，直到遇到能降伏自己的老大，就会在门下。如果最大的老大死啦死啦之后，就会有人接替他的位置，但是如果新老大不够强，手下就会取而代之，那么新的老大最终就会下浮到他合适的位置。那么用有序堆这个数据结构实现优先队列的，那么插入元素只要将新插入的数据置于数组队尾，然后再用上浮算法，他就会去到他合适的位置，删除最大元素 这个实现，只需要取队列第一个数，然后将队尾的最小的数放在首位，让其自由下沉，经过一次大洗盘之后，有是一个有序的堆。那么最终的实现代码为：<br></p>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123;</span><br><span class="line">    private int N =0;</span><br><span class="line">    private Key[] pq ;</span><br><span class="line">    MaxPQ()&#123;&#125;</span><br><span class="line">    MaxPQ(int M)&#123; pq =(Key[]) new Comparable[M+1];&#125;</span><br><span class="line">    MaxPQ(Key[] a)&#123; pq = a ; N = a.length;&#125;</span><br><span class="line"></span><br><span class="line">    void insert(Key v)&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    Key delMax()&#123;</span><br><span class="line">        Key max = pq[1];</span><br><span class="line">        exch(1,N--);</span><br><span class="line">        pq[N+1] = null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isEmpty()&#123;return N == 0;&#125;</span><br><span class="line">    int size()&#123;return N;&#125;</span><br><span class="line">    private boolean less(int i,int j)&#123;</span><br><span class="line">        return pq[i].compareTo(pq[j])&lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    private void exch(int i,int j)&#123;</span><br><span class="line">        Key t = pq[i]; pq[i] = pq[j] ; pq[j] = t ;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swim(int k)&#123;</span><br><span class="line">        while (k&gt;1 &amp;&amp; less(k/2,k))&#123;</span><br><span class="line">            exch(k/2,k);</span><br><span class="line">            k = k /2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sink(int k)&#123;</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            int j = 2*k;</span><br><span class="line">            if(j&lt;N &amp;&amp; less(j,j+1)) j ++;</span><br><span class="line">            if(!less(k,j)) break;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>《算法》（第四版）</p>
</div><div class="tags"><a href="/tags/学习/">学习</a></div><div class="post-nav"><a class="next" href="/2018/07/19/QuickSort/">快速排序</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/MaxPQ/">优先队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/QuickSort/">快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/15/something/">前段时间的一些想法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/24/MdLeaning/">Markdown 语法学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">开开｜初开.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>